Что выведет программа? Объяснить вывод программы.

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func asChan(vs ...int) <-chan int {
	// создаем небуферизованный канал интов
	c := make(chan int)

	// запускаем горутину, затем возвращаем канал
	go func() {
		// запускаем серию таймеров, которые при начале работы отсылают значение,
		// а затем усыпляют горутину на рандомное кол-во миллисекунд
		for _, v := range vs {
			c <- v
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
		}

		// когда все данные отправлены в канал и последний таймер истёк,
		// закрываем канал
		close(c)
	}()
	return c
}

func merge(a, b <-chan int) <-chan int {
	// создаем небуферизованный канал интов
	c := make(chan int)

	// запускаем горутину, которая когда получает данные из каналов a или b,
	// отсылает их в возвращаемый канал
	go func() {
		for {
			select {
			case v := <-a:
				c <- v
			case v := <-b:
				c <- v
			}
		}
	}()

	// возвращаем канал
	return c
}

func main() {
	// a, b - каналы со значениями (1, 3, 5, 7) и (2, 4 ,6, 8) соответственно
	a := asChan(1, 3, 5, 7)
	b := asChan(2, 4 ,6, 8)

	// мерджим каналы a, b
	c := merge(a, b )

	// начинаем выводить в консоль данные из замердженного канала
	for v := range c {
		fmt.Println(v)
	}
}
```

Ответ:
```
undefined behavior

при этом можно гарантировать, что как минимум один из наборов (1, 3, 5, 7) или
(2, 4 ,6, 8) будет выведен, но неизвестно в каком порядке
+ в конце бесконечное кол-во нулей

1. Происходит это из-за того, что когда канал a или b закрывается, из него
бесконечно читаются нули, заспамливая селект и вывод настолько, что (по идее)
данные из другого канала не успевают вывестись
2. Подобный вывод в принципе непредсказуем, т.к. горутины не имеют средств
синхронизации

```
